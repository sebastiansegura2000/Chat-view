{"version":3,"file":"mqtt.service.d.ts","sources":["mqtt.service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA","sourcesContent":["/// <reference types=\"node\" />\nimport { EventEmitter } from '@angular/core';\nimport { IClientPublishOptions, IClientSubscribeOptions, MqttClient } from 'mqtt-browser';\nimport { Packet } from 'mqtt-packet';\nimport { Observable, Subject } from 'rxjs';\nimport { IMqttMessage, IMqttServiceOptions, IOnConnectEvent, IOnErrorEvent, IOnPacketreceiveEvent, IOnPacketsendEvent, IOnSubackEvent, IPublishOptions, MqttConnectionState } from './mqtt.model';\n/**\n * With an instance of MqttService, you can observe and subscribe to MQTT in multiple places, e.g. in different components,\n * to only subscribe to the broker once per MQTT filter.\n * It also handles proper unsubscription from the broker, if the last observable with a filter is closed.\n */\nexport declare class MqttService {\n    private options;\n    private client?;\n    /**\n     * The constructor needs [connection options]{@link IMqttServiceOptions} regarding the broker and some\n     * options to configure behavior of this service, like if the connection to the broker\n     * should be established on creation of this service or not.\n     */\n    constructor(options: IMqttServiceOptions, client?: MqttClient);\n    /**\n     * gets the _clientId\n     */\n    get clientId(): string;\n    /** An EventEmitter to listen to connect messages */\n    get onConnect(): EventEmitter<IOnConnectEvent>;\n    /** An EventEmitter to listen to reconnect messages */\n    get onReconnect(): EventEmitter<void>;\n    /** An EventEmitter to listen to close messages */\n    get onClose(): EventEmitter<void>;\n    /** An EventEmitter to listen to offline events */\n    get onOffline(): EventEmitter<void>;\n    /** An EventEmitter to listen to error events */\n    get onError(): EventEmitter<IOnErrorEvent>;\n    /** An EventEmitter to listen to close messages */\n    get onEnd(): EventEmitter<void>;\n    /** An EventEmitter to listen to message events */\n    get onMessage(): EventEmitter<Packet>;\n    /** An EventEmitter to listen to packetsend messages */\n    get onPacketsend(): EventEmitter<IOnPacketsendEvent>;\n    /** An EventEmitter to listen to packetreceive messages */\n    get onPacketreceive(): EventEmitter<IOnPacketreceiveEvent>;\n    /** An EventEmitter to listen to suback events */\n    get onSuback(): EventEmitter<IOnSubackEvent>;\n    /** a map of all mqtt observables by filter */\n    observables: {\n        [filterString: string]: Observable<IMqttMessage>;\n    };\n    /** the connection state */\n    state: Subject<MqttConnectionState>;\n    /** an observable of the last mqtt message */\n    messages: Subject<IMqttMessage>;\n    private _clientId;\n    private _connectTimeout;\n    private _reconnectPeriod;\n    private _url;\n    private _onConnect;\n    private _onReconnect;\n    private _onClose;\n    private _onOffline;\n    private _onError;\n    private _onEnd;\n    private _onMessage;\n    private _onSuback;\n    private _onPacketsend;\n    private _onPacketreceive;\n    /**\n     * This static method shall be used to determine whether a MQTT\n     * topic matches a given filter. The matching rules are specified in the MQTT\n     * standard documentation and in the library test suite.\n     *\n     * @param  {string}  filter A filter may contain wildcards like '#' and '+'.\n     * @param  {string}  topic  A topic may not contain wildcards.\n     * @return {boolean}        true on match and false otherwise.\n     */\n    static filterMatchesTopic(filterString: string, topic: string): boolean;\n    /**\n     * connect manually connects to the mqtt broker.\n     */\n    connect(opts?: IMqttServiceOptions, client?: MqttClient): void;\n    /**\n     * disconnect disconnects from the mqtt client.\n     * This method `should` be executed when leaving the application.\n     */\n    disconnect(force?: boolean): void;\n    /**\n     * With this method, you can observe messages for a mqtt topic.\n     * The observable will only emit messages matching the filter.\n     * The first one subscribing to the resulting observable executes a mqtt subscribe.\n     * The last one unsubscribing this filter executes a mqtt unsubscribe.\n     * Every new subscriber gets the latest message.\n     */\n    observeRetained(filterString: string, opts?: IClientSubscribeOptions): Observable<IMqttMessage>;\n    /**\n     * With this method, you can observe messages for a mqtt topic.\n     * The observable will only emit messages matching the filter.\n     * The first one subscribing to the resulting observable executes a mqtt subscribe.\n     * The last one unsubscribing this filter executes a mqtt unsubscribe.\n     */\n    observe(filterString: string, opts?: IClientSubscribeOptions): Observable<IMqttMessage>;\n    /**\n     * With this method, you can observe messages for a mqtt topic.\n     * The observable will only emit messages matching the filter.\n     * The first one subscribing to the resulting observable executes a mqtt subscribe.\n     * The last one unsubscribing this filter executes a mqtt unsubscribe.\n     * Depending on the publish function, the messages will either be replayed after new\n     * subscribers subscribe or the messages are just passed through\n     */\n    private _generalObserve;\n    /**\n     * This method returns an observable for a topic with optional options.\n     * After subscribing, the actual mqtt publication will be executed and\n     * the observable will emit an empty value and completes, if publishing was successful\n     * or throws an error, if the publication fails.\n     */\n    publish(topic: string, message: string | Buffer, options?: IClientPublishOptions): Observable<void>;\n    /**\n     * This method publishes a message for a topic with optional options.\n     * If an error occurs, it will throw.\n     */\n    unsafePublish(topic: string, message: string | Buffer, options?: IPublishOptions): void;\n    private _handleOnConnect;\n    private _handleOnReconnect;\n    private _handleOnClose;\n    private _handleOnOffline;\n    private _handleOnError;\n    private _handleOnEnd;\n    private _handleOnMessage;\n    private _handleOnPacketsend;\n    private _handleOnPacketreceive;\n    private _generateClientId;\n}\n"]}